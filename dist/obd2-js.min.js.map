{"version":3,"sources":["obd2-js.min.js"],"names":["angular","module","answerDecoderService","_nextChar","character","String","fromCharCode","charCodeAt","toBitmask","codedValue","valueArray","codedValueWithoutSpaces","replace","WHITE_SPACES","result","length","Error","ERR_INVALID_INPUT","match","index","binaryRepresentation","parseInt","toString","toValueArray","currentIndex","parseAnswer","answer","answerWithoutSpaces","answerFor","substring","factory"],"mappings":"CAAA,WACI,YAGAA,SAAQC,OAAO,QACX,kBAGR,WACI,YAGAD,SACKC,OAAO,oBAEhB,WACI,YAGA,SAASC,KAUL,QAASC,GAAUC,GACf,MAAOC,QAAOC,aAAaF,EAAUG,WAAW,GAAK,GAQzD,QAASC,GAAUC,GACf,GACIC,GADAC,EAA0BF,EAAWG,QAAQC,EAAc,IAE3DC,EAAS,EACb,IAAIH,EAAwBI,OAAS,IAAM,EACvC,KAAM,IAAIC,OAAMC,EAEpBP,GAAaC,EAAwBO,MAAM,UAC3C,KAAI,GAAIC,GAAQ,EAAGA,EAAQT,EAAWK,OAAQI,IAAS,CAEnD,IADA,GAAIC,GAAuBC,SAASX,EAAWS,GAAQ,IAAIG,SAAS,GAC9DF,EAAqBL,OAAS,GAChCK,EAAuB,IAAMA,CAEjCN,IAAUM,EAEd,MAAON,GAQX,QAASS,GAAad,GAClB,GACIC,GADAC,EAA0BF,EAAWG,QAAQC,EAAc,IAE3DW,EAAe,IACfV,IACJ,IAAIH,EAAwBI,OAAS,IAAM,EACvC,KAAM,IAAIC,OAAMC,EAEpBP,GAAaC,EAAwBO,MAAM,UAC3C,KAAI,GAAIC,KAAST,GACbI,EAAOU,GAAgBH,SAASX,EAAWS,GAAQ,IACnDK,EAAerB,EAAUqB,EAE7B,OAAOV,GAQX,QAASW,GAAYC,GACjB,GAAIZ,MACAa,EAAsBD,EAAOd,QAAQC,EAAc,GACvD,IAAGc,EAAoBZ,QAAU,GAAKY,EAAoBZ,OAAS,IAAM,EACrE,KAAM,IAAIC,OAAMC,EAMpB,OAJAH,IACIc,UAAWD,EAAoBE,UAAU,EAAE,GAC3CH,OAAQC,EAAoBE,UAAU,IAtE9C,GAAIZ,GAAoB,gBAEpBJ,EAAe,KAwEnB,QACIY,YAAaA,EACbjB,UAAWA,EACXe,aAAcA,GAItBvB,QACKC,OAAO,cACP6B,QAAQ,gBAAiB5B","file":"obd2-js.min.js","sourcesContent":["(function() {\r\n    'use strict';\r\n    /*global angular*/\r\n    \r\n    angular.module('OBD2', [\r\n        'OBD2.codes'\r\n    ]);\r\n})();\n(function() {\r\n    'use strict';\r\n    /*global angular*/\r\n    \r\n    angular\r\n        .module('OBD2.codes', []);\r\n})();\n(function() {\r\n    'use strict';\r\n    /*global angular*/\r\n\r\n    function answerDecoderService() {\r\n        var ERR_INVALID_INPUT = \"Invalid input\",\r\n            \r\n            WHITE_SPACES = /\\s/g;\r\n        \r\n        /**\r\n         * Function used for iterate over letters\r\n         * @param {char} character - Actual character\r\n         * @returns {char} - The next character in alphabet\r\n         */\r\n        function _nextChar(character) {\r\n            return String.fromCharCode(character.charCodeAt(0) + 1);\r\n        }\r\n        \r\n        /**\r\n         * Function to convert code returned by OBD2 device to bitmask. Used to decode PIDs 0100, 0120, 0140, etc.\r\n         * @param {string} codedValue - Coded message about PID's support\r\n         * @returns {string} - Bitmask of supported functions\r\n         */\r\n        function toBitmask(codedValue) {\r\n            var codedValueWithoutSpaces = codedValue.replace(WHITE_SPACES, ''),\r\n                valueArray,\r\n                result = \"\";\r\n            if (codedValueWithoutSpaces.length % 2 !== 0) {\r\n                throw new Error(ERR_INVALID_INPUT);\r\n            }\r\n            valueArray = codedValueWithoutSpaces.match(/.{1,2}/g);\r\n            for(var index = 0; index < valueArray.length; index++) {\r\n                var binaryRepresentation = parseInt(valueArray[index], 16).toString(2);\r\n                while(binaryRepresentation.length < 8) {\r\n                    binaryRepresentation = '0' + binaryRepresentation;\r\n                }\r\n                result += binaryRepresentation;\r\n            }\r\n            return result;\r\n        }\r\n        \r\n        /**\r\n         * Function to convert hexadecimal value to map of decimal values. The keys are the big letters from alphabet.\r\n         * @param {string} codedValue - Coded value from device.\r\n         * @returns {object} - Map of decimal values.\r\n         */\r\n        function toValueArray(codedValue) {\r\n            var codedValueWithoutSpaces = codedValue.replace(WHITE_SPACES, ''),\r\n                valueArray,\r\n                currentIndex = 'A',\r\n                result = {};\r\n            if (codedValueWithoutSpaces.length % 2 !== 0) {\r\n                throw new Error(ERR_INVALID_INPUT);\r\n            }\r\n            valueArray = codedValueWithoutSpaces.match(/.{1,2}/g);\r\n            for(var index in valueArray) {\r\n                result[currentIndex] = parseInt(valueArray[index], 16);\r\n                currentIndex = _nextChar(currentIndex);\r\n            }\r\n            return result;\r\n        }\r\n        \r\n        /**\r\n         * Function to split answer into answer type and value\r\n         * @param {string} answer - Answer with value from OBD2 device\r\n         * @returns {object} - Object contains PID's answer information and answered value\r\n         */\r\n        function parseAnswer(answer) {\r\n            var result = {},\r\n                answerWithoutSpaces = answer.replace(WHITE_SPACES, '');\r\n            if(answerWithoutSpaces.length <= 4 || answerWithoutSpaces.length % 2 !== 0) {\r\n                throw new Error(ERR_INVALID_INPUT);\r\n            }\r\n            result = {\r\n                answerFor: answerWithoutSpaces.substring(0,4),\r\n                answer: answerWithoutSpaces.substring(4)\r\n            }\r\n            return result;\r\n        }\r\n        return {\r\n            parseAnswer: parseAnswer,\r\n            toBitmask: toBitmask,\r\n            toValueArray: toValueArray\r\n        };\r\n    }\r\n    \r\n    angular\r\n        .module('OBD2.codes')\r\n        .factory('answerDecoder', answerDecoderService);\r\n})();"],"sourceRoot":"/source/"}